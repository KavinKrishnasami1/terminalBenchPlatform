{
  "analysis": "The first test passed successfully, but there's an error in Test 2 (Exponential Distribution) with negative probabilities in the envelope sampling. This is likely due to numerical issues when computing probabilities for segments with infinite bounds. I need to fix the sample_envelope function to handle edge cases better.",
  "plan": "Fix the sample_envelope function to handle cases where bounds are infinite or when numerical issues arise. I'll also improve the handling of exponential segments and add better numerical stability checks.",
  "commands": [
    {
      "keystrokes": "cat > /app/ars.R << 'EOF'\n# Adaptive Rejection Sampling (ARS) Implementation\n# Based on Gilks & Wild (1992)\n# Author: Implementation for statistical computing\n\n################################################################################\n# MAIN ARS FUNCTION\n################################################################################\n\nars <- function(n, f, x_init = NULL, xlim = c(-Inf, Inf), \n                vectorized = TRUE, ...) {\n  \n  # Input validation\n  if (!is.numeric(n) || length(n) != 1 || n <= 0 || n != floor(n)) {\n    stop(\"n must be a positive integer\")\n  }\n  \n  if (!is.function(f)) {\n    stop(\"f must be a function\")\n  }\n  \n  if (length(xlim) != 2 || !is.numeric(xlim)) {\n    stop(\"xlim must be a numeric vector of length 2\")\n  }\n  \n  if (xlim[1] >= xlim[2]) {\n    stop(\"xlim[1] must be less than xlim[2]\")\n  }\n  \n  # Initialize the abscissae (starting points)\n  if (is.null(x_init)) {\n    x_init <- initialize_abscissae(xlim)\n  }\n  \n  if (length(x_init) < 2) {\n    stop(\"Need at least 2 initial points\")\n  }\n  \n  x_init <- sort(unique(x_init))\n  \n  # Evaluate log density at initial points\n  h <- function(x) {\n    result <- f(x, ...)\n    if (any(result < 0)) {\n      stop(\"Density function returned negative values\")\n    }\n    if (any(result == 0)) {\n      return(rep(-Inf, length(result)))\n    }\n    return(log(result))\n  }\n  \n  # Initialize envelope\n  T_k <- x_init\n  h_k <- h(T_k)\n  \n  if (any(!is.finite(h_k))) {\n    stop(\"Initial points produced non-finite log-density values\")\n  }\n  \n  # Compute derivatives\n  hprime_k <- compute_derivatives(T_k, h)\n  \n  # Check log-concavity at initial points\n  if (!check_log_concavity(T_k, h_k, hprime_k)) {\n    stop(\"Function is not log-concave at initial points\")\n  }\n  \n  # Sample\n  samples <- numeric(n)\n  n_sampled <- 0\n  n_rejected <- 0\n  max_iterations <- n * 1000  # Prevent infinite loops\n  iterations <- 0\n  \n  while (n_sampled < n && iterations < max_iterations) {\n    iterations <- iterations + 1\n    \n    # Compute envelope (upper hull)\n    envelope <- compute_envelope(T_k, h_k, hprime_k, xlim)\n    \n    # Sample from envelope\n    x_star <- sample_envelope(envelope)\n    \n    # Compute lower hull\n    l_x <- compute_lower_hull(x_star, T_k, h_k)\n    \n    # Compute upper hull at x_star\n    u_x <- evaluate_envelope(x_star, envelope)\n    \n    # Squeezing test\n    w <- runif(1)\n    \n    if (w <= exp(l_x - u_x)) {\n      # Accept without evaluating h\n      n_sampled <- n_sampled + 1\n      samples[n_sampled] <- x_star\n    } else {\n      # Evaluate h at x_star\n      h_star <- h(x_star)\n      \n      # Rejection test\n      if (w <= exp(h_star - u_x)) {\n        n_sampled <- n_sampled + 1\n        samples[n_sampled] <- x_star\n      } else {\n        n_rejected <- n_rejected + 1\n      }\n      \n      # Update envelope\n      T_k <- sort(c(T_k, x_star))\n      h_k <- h(T_k)\n      hprime_k <- compute_derivatives(T_k, h)\n      \n      # Check log-concavity\n      if (!check_log_concavity(T_k, h_k, hprime_k)) {\n        stop(\"Function is not log-concave - detected during sampling\")\n      }\n    }\n  }\n  \n  if (iterations >= max_iterations) {\n    warning(\"Maximum iterations reached. Only \", n_sampled, \" samples generated.\")\n    return(samples[1:n_sampled])\n  }\n  \n  return(samples)\n}\n\n################################################################################\n# HELPER FUNCTIONS\n################################################################################\n\ninitialize_abscissae <- function(xlim) {\n  # Initialize starting points for the envelope\n  \n  if (is.finite(xlim[1]) && is.finite(xlim[2])) {\n    # Bounded support\n    range <- xlim[2] - xlim[1]\n    return(c(xlim[1] + 0.1 * range, \n             xlim[1] + 0.5 * range, \n             xlim[1] + 0.9 * range))\n  } else if (is.finite(xlim[1]) && is.infinite(xlim[2])) {\n    # Lower bounded\n    return(c(xlim[1] + 0.1, xlim[1] + 1, xlim[1] + 2))\n  } else if (is.infinite(xlim[1]) && is.finite(xlim[2])) {\n    # Upper bounded\n    return(c(xlim[2] - 2, xlim[2] - 1, xlim[2] - 0.1))\n  } else {\n    # Unbounded\n    return(c(-1, 0, 1))\n  }\n}\n\ncompute_derivatives <- function(x, h, eps = 1e-6) {\n  # Compute numerical derivatives of log-density\n  n <- length(x)\n  hprime <- numeric(n)\n  \n  for (i in 1:n) {\n    # Use central differences where possible\n    if (i == 1) {\n      hprime[i] <- (h(x[i] + eps) - h(x[i])) / eps\n    } else if (i == n) {\n      hprime[i] <- (h(x[i]) - h(x[i] - eps)) / eps\n    } else {\n      hprime[i] <- (h(x[i] + eps) - h(x[i] - eps)) / (2 * eps)\n    }\n  }\n  \n  return(hprime)\n}\n\ncheck_log_concavity <- function(T_k, h_k, hprime_k) {\n  # Check that derivatives are decreasing (log-concavity condition)\n  if (length(T_k) < 2) return(TRUE)\n  \n  # Check that h'(x) is decreasing\n  for (i in 2:length(T_k)) {\n    if (hprime_k[i] > hprime_k[i-1] + 1e-6) {\n      return(FALSE)\n    }\n  }\n  \n  return(TRUE)\n}\n\ncompute_envelope <- function(T_k, h_k, hprime_k, xlim) {\n  # Compute piecewise linear upper hull\n  n <- length(T_k)\n  \n  # Compute intersection points z\n  z <- numeric(n + 1)\n  z[1] <- xlim[1]\n  z[n + 1] <- xlim[2]\n  \n  for (i in 2:n) {\n    # Intersection of tangent lines at T_k[i-1] and T_k[i]\n    if (abs(hprime_k[i-1] - hprime_k[i]) < 1e-10) {\n      # Nearly parallel lines - use midpoint\n      z[i] <- (T_k[i-1] + T_k[i]) / 2\n    } else {\n      z[i] <- (h_k[i] - h_k[i-1] - T_k[i] * hprime_k[i] + T_k[i-1] * hprime_k[i-1]) /\n              (hprime_k[i-1] - hprime_k[i])\n    }\n  }\n  \n  list(T_k = T_k, h_k = h_k, hprime_k = hprime_k, z = z)\n}\n\nevaluate_envelope <- function(x, envelope) {\n  # Evaluate upper hull at x\n  T_k <- envelope$T_k\n  h_k <- envelope$h_k\n  hprime_k <- envelope$hprime_k\n  z <- envelope$z\n  \n  # Find which segment x is in\n  n <- length(T_k)\n  for (i in 1:n) {\n    if (x >= z[i] && x < z[i+1]) {\n      # Use tangent line at T_k[i]\n      return(h_k[i] + (x - T_k[i]) * hprime_k[i])\n    }\n  }\n  \n  # If we get here, x is in the last segment\n  return(h_k[n] + (x - T_k[n]) * hprime_k[n])\n}\n\ncompute_lower_hull <- function(x, T_k, h_k) {\n  # Compute lower hull (piecewise linear through points)\n  n <- length(T_k)\n  \n  if (x <= T_k[1]) {\n    return(-Inf)\n  } else if (x >= T_k[n]) {\n    return(-Inf)\n  }\n  \n  # Find interval containing x\n  for (i in 1:(n-1)) {\n    if (x >= T_k[i] && x <= T_k[i+1]) {\n      # Linear interpolation\n      return(h_k[i] + (h_k[i+1] - h_k[i]) * (x - T_k[i]) / (T_k[i+1] - T_k[i]))\n    }\n  }\n  \n  return(-Inf)\n}\n\nsample_envelope <- function(envelope) {\n  # Sample from the piecewise exponential envelope\n  T_k <- envelope$T_k\n  h_k <- envelope$h_k\n  hprime_k <- envelope$hprime_k\n  z <- envelope$z\n  \n  n <- length(T_k)\n  \n  # Compute unnormalized probabilities for each segment\n  probs <- numeric(n)\n  \n  for (i in 1:n) {\n    # Handle infinite bounds\n    z_lower <- z[i]\n    z_upper <- z[i+1]\n    \n    # Skip segments with infinite bounds and positive slope or negative slope issues\n    if (is.infinite(z_lower) && hprime_k[i] >= 0) {\n      probs[i] <- 0\n      next\n    }\n    if (is.infinite(z_upper) && hprime_k[i] <= 0) {\n      probs[i] <- 0\n      next\n    }\n    \n    # For infinite lower bound with negative slope\n    if (is.infinite(z_lower) && hprime_k[i] < 0) {\n      # Integral from -Inf to z_upper\n      probs[i] <- exp(h_k[i] + (z_upper - T_k[i]) * hprime_k[i]) / abs(hprime_k[i])\n      next\n    }\n    \n    # For infinite upper bound with positive slope\n    if (is.infinite(z_upper) && hprime_k[i] > 0) {\n      # Integral from z_lower to Inf\n      probs[i] <- exp(h_k[i] + (z_lower - T_k[i]) * hprime_k[i]) / abs(hprime_k[i])\n      next\n    }\n    \n    # Finite bounds\n    if (abs(hprime_k[i]) < 1e-10) {\n      # Nearly flat segment\n      probs[i] <- exp(h_k[i]) * (z_upper - z_lower)\n    } else {\n      # Exponential segment\n      exp_upper <- exp(h_k[i] + (z_upper - T_k[i]) * hprime_k[i])\n      exp_lower <- exp(h_k[i] + (z_lower - T_k[i]) * hprime_k[i])\n      probs[i] <- abs(exp_upper - exp_lower) / abs(hprime_k[i])\n    }\n  }\n  \n  # Ensure all probabilities are non-negative\n  probs <- pmax(probs, 0)\n  \n  if (sum(probs) == 0) {\n    stop(\"All segment probabilities are zero - check envelope construction\")\n  }\n  \n  # Sample segment\n  segment <- sample(1:n, 1, prob = probs)\n  \n  # Sample within segment\n  u <- runif(1)\n  z_lower <- z[segment]\n  z_upper <- z[segment+1]\n  \n  if (abs(hprime_k[segment]) < 1e-10) {\n    # Uniform sampling for flat segment\n    x <- z_lower + u * (z_upper - z_lower)\n  } else {\n    # Inverse CDF for exponential segment\n    a <- hprime_k[segment]\n    b <- h_k[segment] - T_k[segment] * hprime_k[segment]\n    \n    if (is.infinite(z_lower) && a < 0) {\n      # Sample from -Inf to z_upper\n      exp_x <- u * exp(a * z_upper + b)\n      x <- (log(exp_x) - b) / a\n    } else if (is.infinite(z_upper) && a > 0) {\n      # Sample from z_lower to Inf\n      exp_x <- exp(a * z_lower + b) / u\n      x <- (log(exp_x) - b) / a\n    } else {\n      # Finite bounds\n      exp_z_lower <- exp(a * z_lower + b)\n      exp_z_upper <- exp(a * z_upper + b)\n      \n      exp_x <- exp_z_lower + u * (exp_z_upper - exp_z_lower)\n      x <- (log(exp_x) - b) / a\n    }\n  }\n  \n  return(x)\n}\n\n################################################################################\n# TEST FUNCTION\n################################################################################\n\ntest <- function() {\n  cat(\"\\n=== ADAPTIVE REJECTION SAMPLING TESTS ===\\n\\n\")\n  \n  all_passed <- TRUE\n  \n  # Test 1: Standard Normal Distribution\n  cat(\"Test 1: Standard Normal Distribution\\n\")\n  set.seed(123)\n  samples_norm <- ars(n = 10000, f = dnorm, x_init = c(-2, 0, 2))\n  \n  mean_norm <- mean(samples_norm)\n  sd_norm <- sd(samples_norm)\n  \n  cat(sprintf(\"  Sample mean: %.4f (expected: 0.0000)\\n\", mean_norm))\n  cat(sprintf(\"  Sample SD: %.4f (expected: 1.0000)\\n\", sd_norm))\n  \n  # Use wider tolerance for stochastic test\n  if (abs(mean_norm) < 0.05 && abs(sd_norm - 1) < 0.05) {\n    cat(\"  TEST 1: PASS\\n\\n\")\n  } else {\n    cat(\"  TEST 1: FAIL\\n\\n\")\n    all_passed <- FALSE\n  }\n  \n  # Test 2: Exponential Distribution (rate = 1)\n  cat(\"Test 2: Exponential Distribution (rate = 1)\\n\")\n  set.seed(456)\n  f_exp <- function(x) ifelse(x >= 0, dexp(x, rate = 1), 0)\n  samples_exp <- ars(n = 10000, f = f_exp, x_init = c(0.1, 1, 3), xlim = c(0, Inf))\n  \n  mean_exp <- mean(samples_exp)\n  sd_exp <- sd(samples_exp)\n  \n  cat(sprintf(\"  Sample mean: %.4f (expected: 1.0000)\\n\", mean_exp))\n  cat(sprintf(\"  Sample SD: %.4f (expected: 1.0000)\\n\", sd_exp))\n  \n  if (abs(mean_exp - 1) < 0.05 && abs(sd_exp - 1) < 0.05) {\n    cat(\"  TEST 2: PASS\\n\\n\")\n  } else {\n    cat(\"  TEST 2: FAIL\\n\\n\")\n    all_passed <- FALSE\n  }\n  \n  # Test 3: Beta Distribution (a=2, b=2)\n  cat(\"Test 3: Beta Distribution (a=2, b=2)\\n\")\n  set.seed(789)\n  f_beta <- function(x) dbeta(x, 2, 2)\n  samples_beta <- ars(n = 10000, f = f_beta, x_init = c(0.2, 0.5, 0.8), xlim = c(0, 1))\n  \n  mean_beta <- mean(samples_beta)\n  sd_beta <- sd(samples_beta)\n  \n  expected_mean_beta <- 0.5\n  expected_sd_beta <- sqrt(2*2/((2+2)^2*(2+2+1)))\n  \n  cat(sprintf(\"  Sample mean: %.4f (expected: %.4f)\\n\", mean_beta, expected_mean_beta))\n  cat(sprintf(\"  Sample SD: %.4f (expected: %.4f)\\n\", sd_beta, expected_sd_beta))\n  \n  if (abs(mean_beta - expected_mean_beta) < 0.05 && abs(sd_beta - expected_sd_beta) < 0.05) {\n    cat(\"  TEST 3: PASS\\n\\n\")\n  } else {\n    cat(\"  TEST 3: FAIL\\n\\n\")\n    all_passed <- FALSE\n  }\n  \n  # Test 4: Input Validation - Negative n\n  cat(\"Test 4: Input Validation - Negative n\\n\")\n  test_passed <- FALSE\n  tryCatch({\n    ars(n = -5, f = dnorm)\n  }, error = function(e) {\n    if (grepl(\"positive integer\", e$message)) {\n      test_passed <<- TRUE\n    }\n  })\n  \n  if (test_passed) {\n    cat(\"  TEST 4: PASS\\n\\n\")\n  } else {\n    cat(\"  TEST 4: FAIL\\n\\n\")\n    all_passed <- FALSE\n  }\n  \n  # Test 5: Log-concavity Check - Non-log-concave function\n  cat(\"Test 5: Log-concavity Check - Non-log-concave function\\n\")\n  test_passed <- FALSE\n  tryCatch({\n    # A bimodal distribution (not log-concave)\n    f_bimodal <- function(x) 0.5 * dnorm(x, -2, 0.5) + 0.5 * dnorm(x, 2, 0.5)\n    ars(n = 100, f = f_bimodal, x_init = c(-3, 0, 3))\n  }, error = function(e) {\n    if (grepl(\"not log-concave\", e$message)) {\n      test_passed <<- TRUE\n    }\n  })\n  \n  if (test_passed) {\n    cat(\"  TEST 5: PASS\\n\\n\")\n  } else {\n    cat(\"  TEST 5: FAIL\\n\\n\")\n    all_passed <- FALSE\n  }\n  \n  # Test 6: Gamma Distribution (shape=2, rate=1)\n  cat(\"Test 6: Gamma Distribution (shape=2, rate=1)\\n\")\n  set.seed(321)\n  f_gamma <- function(x) ifelse(x >= 0, dgamma(x, shape = 2, rate = 1), 0)\n  samples_gamma <- ars(n = 10000, f = f_gamma, x_init = c(0.5, 2, 4), xlim = c(0, Inf))\n  \n  mean_gamma <- mean(samples_gamma)\n  sd_gamma <- sd(samples_gamma)\n  \n  expected_mean_gamma <- 2\n  expected_sd_gamma <- sqrt(2)\n  \n  cat(sprintf(\"  Sample mean: %.4f (expected: %.4f)\\n\", mean_gamma, expected_mean_gamma))\n  cat(sprintf(\"  Sample SD: %.4f (expected: %.4f)\\n\", sd_gamma, expected_sd_gamma))\n  \n  if (abs(mean_gamma - expected_mean_gamma) < 0.1 && abs(sd_gamma - expected_sd_gamma) < 0.1) {\n    cat(\"  TEST 6: PASS\\n\\n\")\n  } else {\n    cat(\"  TEST 6: FAIL\\n\\n\")\n    all_passed <- FALSE\n  }\n  \n  # Summary\n  cat(\"\\n=== TEST SUMMARY ===\\n\")\n  if (all_passed) {\n    cat(\"ALL TESTS PASSED\\n\\n\")\n  } else {\n    cat(\"SOME TESTS FAILED\\n\\n\")\n  }\n  \n  # Generate sample output files\n  cat(\"Generating sample output files...\\n\")\n  \n  set.seed(999)\n  normal_samples <- ars(n = 1000, f = dnorm, x_init = c(-2, 0, 2))\n  write.table(normal_samples, file = \"/app/normal_samples.txt\", \n              row.names = FALSE, col.names = FALSE)\n  cat(\"  Written: /app/normal_samples.txt\\n\")\n  \n  exponential_samples <- ars(n = 1000, f = f_exp, x_init = c(0.1, 1, 3), xlim = c(0, Inf))\n  write.table(exponential_samples, file = \"/app/exponential_samples.txt\", \n              row.names = FALSE, col.names = FALSE)\n  cat(\"  Written: /app/exponential_samples.txt\\n\\n\")\n  \n  invisible(all_passed)\n}\nEOF\n",
      "duration": 0.5
    }
  ]
}